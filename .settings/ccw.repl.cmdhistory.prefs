#Mon Dec 26 21:54:10 GMT 2011
cmdhistory=[";; Loading file src\\\\problem03.clj" "(ceil 1.1)" "(clojure.contrib.math/ceil 1.1)" "(int (clojure.contrib.math/ceil 1.1))" "(int (clojure.contrib.math/ceil (clojure.contrib.math/sqrt 600851475143)))" ";; Loading file src\\\\problem03.clj" "(int (clojure.contrib.math/ceil (clojure.contrib.math/sqrt nbr)))" "(int (clojure.contrib.math/ceil (clojure.contrib.math/sqrt 10)))" "(/ 600851475143 2)" ";; Loading file src\\\\problem03.clj" "(first (divisors 600851475143))" "(first (problem03/divisors 600851475143))" ";; Loading file src\\\\problem03.clj" "(first (problem03/divisors 600851475143))" ";; Loading file src\\\\problem03.clj" "(take 10(lazy-stream-inc 10000000000))" "(take 10 (problem03/lazy-stream-inc 10000000000))" ";; Loading file src\\\\problem03.clj" "(problem03/divisors 10)" ";; Loading file src\\\\problem03.clj" "(problem03/divisors 30)" ";; Loading file src\\\\problem03.clj" "(get-factors 6552)" "(problem03/get-factors 6552)" ";; Loading file src\\\\problem03.clj" "(problem03/get-factors 6552)" ";; Loading file src\\\\problem03.clj" "(problem03/get-factors 6552)" "(problem03/get-factors 15265524)" "(problem03/get-factors 60085147)" ";; Loading file src\\\\problem03.clj" "(problem03/get-factors 60085147)" "(problem03/get-factors 600851475143)" "(problem03/get-factors 13195)" ";; Loading file src\\\\problem03.clj" "(problem03/get-factors 13195)" ";; Loading file src\\\\problem03.clj" "(problem03/get-factors 13195)" "(problem03/get-factors 600851475143)" "(reduce max (71 839 1471 6857))" "(reduce max '(71 839 1471 6857))" ";; Loading file src\\\\problem03.clj" ";; Loading file src\\\\problem04.clj" ";; Loading file src\\\\problem03.clj" ";; Loading file src\\\\problem04.clj" "(sort '(5 2))" "(distinct '(1 2) '(1 2) '(2 3))" "(distinct (list '(1 2) '(1 2) '(2 3)))" "(reverse \\"abcde\\")" "(\= \\"aba\\" \\"aba\\")" "(\= \\"aba\\" (reverse \\"aba\\"))" "(doc reverse\\n     )" "(doc distinct)" "(.toString (reverse \\"aba\\"))" "(str 123)" "(reverse (str 123))" "(str (reverse (str 123)))" "(join (reverse (str 123)))" "(doc join\\n     )" "(reverse (reverse \\"123\\"))" "(str (reverse 123))" "(str (reverse \\"123\\"))" "(\= (reverse \\"aba\\") (reverse (reverse \\"aba\\")))" ";; Loading file src\\\\problem04.clj" "(problem04/is-palindrome? 999992299999)" "(problem04/is-palindrome? 999992291999)" "(map (fn[n] (list n n)) '(1 2 3))" "(map (fn[n] (list (list n n))) '(1 2 3))" " (mapcat (fn[n] (list (list n n))) '(1 2 3))" "(mapcat \\n  (fn[n] (list \\n           (mapcat \\n             (fn[y] (list n y)) \\n             '(1 2 3)))) \\n  '(1 2 3))" "(mapcat \\r\\n     (fn[n] (list \\r\\n              (map \\r\\n                (fn[y] (list n y)) \\r\\n                '(1 2 3)))) \\r\\n     '(1 2 3))" "(mapcat \\r\\n        (fn[n] (list \\r\\n                 (map \\r\\n                   (fn[y] (sort (list n y))) \\r\\n                   '(1 2 3)))) \\r\\n        '(1 2 3))" "(map\\r\\n           (fn[n] (list \\r\\n                    (map \\r\\n                      (fn[y] (sort (list n y))) \\r\\n                      '(1 2 3)))) \\r\\n           '(1 2 3))" "(mapcat\\r\\n  (fn[n] (list \\r\\n                       (mapcat\\r\\n                         (fn[y] (sort (list n y))) \\r\\n                         '(1 2 3)))) \\r\\n              '(1 2 3))" "(mapcat\\r\\n    (fn[n] \\r\\n             (mapcat\\r\\n    (fn[y] (sort (list n y))) \\r\\n    '(1 2 3)))\\r\\n'(1 2 3))" ";; Loading file src\\\\problem04.clj" ";; Loading file src\\\\problem03.clj" ";; Loading file src\\\\problem06.clj" "(lazy-stream 10 1)" "(lazy-stream 10)" ";; Loading file src\\\\problem06.clj" ";; Loading file src\\\\problem04.clj" "(problem04/is-palindrome? 9998999)" "(let \\r\\n  [full (lazy-stream 301 100)]\\r\\n\\t(distinct \\r\\n   (mapcat\\r\\n\\t  (fn[n] \\r\\n\\t    (map\\r\\n\\t        (fn[y] (sort (list n y))) \\r\\n\\t         full))\\r\\n\\t  full)))" ";; Loading file src\\\\problem04.clj" "(problem04/is-palindrome? 9009)" ";; Loading file src\\\\problem04.clj" "(second '(1))" ";; Loading file src\\\\problem10.clj" "(nth 1 '(1 2 3))" "(nth '(1 2 3) 1)" ";; Loading file src\\\\problem10.clj" "(defn primes-iteration [ls th]\\r\\n  ; Get elem in *th*th place\\r\\n  ; Remove all multiples of elem in ls\\r\\n  ; Next iteration\\r\\n  ; If th is outside the list, return ls\\r\\n  (let [elem (nth ls th)]\\r\\n    (if (nil? elem)\\r\\n      ls\\r\\n      (primes-iteration \\r\\n        (filter \#(or (\= % elem) (not (is-divisor-of elem %)) ) ls) \\r\\n        (+ th 1))))\\n  \\r\\n(nth 1000 '(1 2 3))" "(nth '(1 2 3 ) 123)" "(first '())" "(cons '(1 2 3) 4)" "(cons 4 '(1 2 3))" "(cons '(1 2 3) '(4))" ";; Loading file src\\\\problem10.clj" ";; Loading file src\\\\problem16.clj" ";; Loading file src\\\\problem10.clj" "(*)" ";; Loading file src\\\\problem16.clj" "(problem16/power 2 2)" "(defn power [base exp]\\r\\n  (cond\\r\\n    (\= exp 0) 1\\r\\n    (\= exp 1) base\\r\\n    (true) (if (\= 0 (mod exp 2))\\r\\n\\t    (let [parcial (power base(/ exp 2))]\\r\\n\\t      (* parcial parcial))\\r\\n\\t    (let [parcial (power base (/ (exp - 1) 2))]\\r\\n\\t      (* parcial parcial base)))))" "(power 2 2)" "(problem16/power 2 2)" ";; Loading file src\\\\problem16.clj" "(problem16/power 2 2)" "(problem16/power 2 100)" "(problem16/power 2 5)" ";; Loading file src\\\\problem16.clj" "(+ 1 1)" "(str 1232)" "(map (fn[n] n) (str 1232))" "(reduce + (map (fn[n] n) (str 1232)))" "(reduce + (map (fn[n] (int n)) (str 1232)))" "(reduce + (map (fn[n] (int (str n))) (str 1232)))" "(int \\"1\\")" "(int \\\\1)" "(int \\\\0\\n     )" "(reduce + (map (fn[n] (- (int n) 48)) (str 1232)))" ";; Loading file src\\\\problem16.clj" ";; Loading file src\\\\problem20.clj" "(doc first)" "(doc \\n  take)" "(doc filter)" ";; Loading file src\\\\problem12.clj" "(take 1 (problem12/triang))" "(cons 3 (triang 3 3))" "(cons 3 (problem12/triang 3 3))" ";; Loading file src\\\\problem12.clj" "(lazy-seq (cons 3 (triang 3 3)))" "(lazy-seq (cons 3 (problem12/triang 3 3)))" ";; Loading file src\\\\problem20.clj" ";; Loading file src\\\\problem03.clj" ";; Loading file src\\\\problem10.clj" "(+ 1 1)" "(doc line-seq)" "(seq 1 20)" "(list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20)" ";; Loading file src\\\\problem05.clj" "(filter \#(\= % 1) (list 1 2 3))" "(doc some)" "(mapcat \\r\\n    (fn[i](list i))\\r\\n    (list 1 2 3))" "(list)" "(doc difference)" "(range 1 20)" "(+ 1 1)" "(first '(1 2 3))" "(rest '(1 2 3))" "(empty? '())\\n" "(first '())" "(filter \#(\= % 1) '(1 2 3))" "(filter \#(\= % 1) '(2 3))\\n" "(values (filter \#(\= % 1) '(2 3)))" ";; Loading file src\\\\problem05.clj" "(list-contains-items '(1 2 3) '(1 2))" "(problem05/list-contains-items '(1 2 3) '(1 2))" ";; Loading file src\\\\problem05.clj" "(problem05/list-contains-items '(1 2 3) '(1 2))" "(problem05/list-contains-items '(1 2 3) '(1 3))" "(problem05/list-contains-items '(1 2 3) '(1 4))" "(problem05/list-contains-items '(1 2 3) '(1 2 3 4))" ";; Loading file src\\\\problem05.clj" ";; Loading file src\\\\problem03.clj" ";; Loading file src\\\\problem05.clj" "(range 20 2)" "(reverse (range 2 20))" "(reverse (range 2 21))" ";; Loading file src\\\\problem05.clj" ";; Loading file src\\\\problem03.clj" ";; Loading file src\\\\problem05.clj" "(reduce min '(1 2 3 4 5 6 7) '(4 5 6))" "(+ 1 1)" ";; Loading file src\\\\problem03.clj" ";; Loading file src\\\\problem05.clj" "(problem03/divisors 20)" "(problem03/divisors 19)" "(problem03/divisors 18)" " (problem03/divisors 17)" " (problem03/divisors 16)" "(problem03/divisors 15)" "(problem03/divisors 14)" "(problem03/divisors 13)" "(problem03/divisors 12)" "(range 10 21)" "(reverse (range 10 21))" "(get-first-with-divisors 2 (list 10 9 8 7 6))" "(problem05/get-first-with-divisors 2 (list 10 9 8 7 6))" "(problem05/get-first-with-divisors 10 10 (list 10 9 8 7 6))" ";; Loading file src\\\\problem05.clj" "(problem05/get-first-with-divisors 2 (list 10 9 8 7 6))" "(problem05/get-first-with-divisors 10 10 (list 10 9 8 7 6))" ";; Loading file src\\\\problem05.clj" "(problem05/get-first-with-divisors 10 10 (list 10 9 8 7 6))" "(problem05/get-first-with-divisors 20 20 (reverse (range 10 21)))" "(problem05/get-first-with-divisors 11 11 (list 20))" "(problem05/get-first-with-divisors 220 11 (list 20))" "(problem05/get-first-with-divisors 221 1 (list 20))" "(problem05/get-first-with-divisors 241 1 (list 20))" ";; Loading file src\\\\problem05.clj" "(get-factors 20)" "(get-factors 19)" "(get-factors 18)" "(get-factors 17)" "(get-factors 16)" "(get-factors 15)" "(concat '() '(1 2 3))" "(concat '() '((1 2 3)))" ";; Loading file src\\\\problem05.clj" "(problem05/serial-factorization 2)" "(problem05/serial-factorization '(2))" "(problem05/serial-factorization '(2 3 4 5 6))" ";; Loading file src\\\\problem05.clj" "(mapcat \#(%) (serial-factorization '(11 12 13 14 15 16 17 18 19 20))" "(mapcat \#(%) (serial-factorization '(11 12 13 14 15 16 17 18 19 20)))" "(mapcat \#(%) (problem05/serial-factorization '(11 12 13 14 15 16 17 18 19 20)))" " (mapcat \#{%} (problem05/serial-factorization '(11 12 13 14 15 16 17 18 19 20)))" "(mapcat (fn[n] n) (problem05/serial-factorization '(11 12 13 14 15 16 17 18 19 20)))" ";; Loading file src\\\\problem05.clj" "(range 2 11)" ";; Loading file src\\\\problem05.clj" "(serial-factorization (list 10 9 8 7 6))" "(problem05/serial-factorization (list 10 9 8 7 6))" "(problem05/serial-factorization (list 3 2))" "(reduce * (mapcat (fn[n] n) (problem05/serial-factorization (list 2 3))))" "(reduce * (mapcat (fn[n] n) (problem05/serial-factorization (list 2 3 4))))" "(reduce * (mapcat (fn[n] n) (problem05/serial-factorization (list 2 3 4 5)))) " "(reduce * (mapcat (fn[n] n) (problem05/serial-factorization (list 2 3 4 5 6))))" "(reduce * (mapcat (fn[n] n) (problem05/serial-factorization (list 2 3 4 5 6 7))))" "(reduce * (mapcat (fn[n] n) (problem05/serial-factorization (list 2 3 4 5 6 7 8 9 10))))" "(reduce * (mapcat (fn[n] n) (problem05/serial-factorization (list 2 3 5 7))))" "(serial-factorization '(2 4 8 10 12 14 16 18 20))" "(problem05/serial-factorization '(2 4 8 10 12 14 16 18 20))" "(doc remove)" "(reduce * (mapcat (fn[n] n) (serial-factorization (list 10 9 8 7 6))))" "(reduce * (mapcat (fn[n] n) (problem05/serial-factorization (list 10 9 8 7 6))))" "(mapcat (fn[n] n) (problem05/serial-factorization (list 10 9 8 7 6)))" ";; Loading file src\\\\problem05.clj" "(problem05/serial-factorization (list 11 12 13 14 15 16 17 18 19 20))" "(doc hash)" "(make-map)" "{}" "(get {\:a \\"teste\\" \:b \\"oopsi\!\\"}, \:a)" "(max nil 3)" "(get {\:a \\"teste\\" \:b \\"oopsi\!\\"}, \:c)" "(get {\:a \\"teste\\" \:b \\"oopsi\!\\"} \:c)" "(get {\:a \\"teste\\" \:b \\"oopsi\!\\"} \:c 0)" "(concat {\:a \\"teste\\" \:b \\"oopsi\!\\"} {\:c 0})" "(concat {\:a \\"teste\\" \:b \\"oopsi\!\\"} {\:a 0})" "(get (concat {\:a \\"teste\\" \:b \\"oopsi\!\\"} {\:a 0}))" "(get (concat {\:a \\"teste\\" \:b \\"oopsi\!\\"} {\:a 0}) \:a)" "(get (concat {\:a \\"teste\\" \:b \\"oopsi\!\\"} {\:a 0}) \:b)" "(concat {\:a \\"teste\\"} {\:b \\"teste\\"})" "{\:a \\"teste\\"}" "(assoc {\:a \:teste} \:b \:opsi)" "(assoc {\:a \:teste} \:a \:opsi)" ";; Loading file src\\\\problem05.clj" "(problem05/decompose-list (1 1 1 3 3 7))" " (problem05/decompose-list (1 1 1 3 3 7) {})" ";; Loading file src\\\\problem05.clj" "(problem05/decompose-list '(1 2 3) {})" ";; Loading file src\\\\problem05.clj" "(problem05/decompose-list '(1 2 3) {})" "(problem05/decompose-list '(1 2 3) {4 1 5 6})" ";; Loading file src\\\\problem05.clj" "(problem05/decompose (problem05/serial-factorization '(1 2 3 4 5 6 7 8 9 10)))" "(* 7 (* 5 2) (* 4 3) (* 8 2))" ";; Loading file src\\\\problem05.clj" ";; Loading file src\\\\problem16.clj" ";; Loading file src\\\\problem05.clj" "(power 5 2)" "(problem16/power 5 2)" ";; Loading file src\\\\problem05.clj" "(mapcat (fn[n] n) {\:a \:opsi})" "(map (fn[n] n) {\:a \:opsi})" "(first (map (fn[n] n) {\:a \:opsi}))" "(first (first (map (fn[n] n) {\:a \:opsi})))" ";; Loading file src\\\\problem05.clj" "(doc reduce)" ";; Loading file src\\\\problem05.clj" "(problem05/decompose (problem05/serial-factorization (range 2 11)))" "(problem16/power 2 8)" "(* (problem16/power 2 8) (problem16/power 7 1) (problem16/power 5 2) (problem16/power 3 4))" ";; Loading file src\\\\problem05.clj" "(problem05/decompose (problem05/serial-factorization (list 2 3 4)))" "(problem05/serial-factorization (list 2 3 4))" "(\!\= 1 2)" "(<> 1 2)" "(not\= 1 2)" "(count '(1 2 3))" ";; Loading file src\\\\problem05.clj" ";; Loading file src\\\\problem14.clj" "(function 13)" "(problem14/function 13)" ";; Loading file src\\\\problem14.clj" "(problem14/function 13)" "(+ 1 1)" "(concat '(1 2 3) 4)" " (concat '(1 2 3) (4))" " (concat '(1 2 3) '(4))" "(mod 4 2)" "(mod 5 2)" ";; Loading file src\\\\problem14.clj" "(problem14/function 2)" "(problem14/function 13)" "(problem14/function 4)" "(problem14/function 2)" ";; Loading file src\\\\problem14.clj" "(problem14/function 13)" "(problem14/function 4)" ";; Loading file src\\\\problem14.clj" "(problem14/function 4)" "(problem14/function 2)" ";; Loading file src\\\\problem14.clj" "(problem14/function 1)" "(problem14/function 2)" "(problem14/function 3)" ";; Loading file src\\\\problem14.clj" "(problem14/function 4)" "(problem14/function 13)" "(problem14/function 100)" "(problem14/function 1000)" "(problem14/function 10000)" "(problem14/function 100000)" "(problem14/function 999999)" "(> 4 2)" ";; Loading file src\\\\problem14.clj" "(doc range)" "(range 1 1000000)" "(range 1 20)" "(range 1 10000)" "(second (range 1 10000))" "(nth (range 1 10000) 555)  " ";; Loading file src\\\\problem14.clj" "(reduce \\r\\n  \\r\\n  (fn[acc v] \\r\\n    (if (> (second v) (second acc))\\r\\n      v\\r\\n      acc))\\r\\n  \\r\\n  '(-1 -1)\\r\\n  \\r\\n  (mapcat\\r\\n    (list n (count (function n)))\\r\\n    (range 1 10)))" ";; Loading file src\\\\problem14.clj" "(mapcat\\r\\n    (fn[n] (list n (count (problem14/function n))))\\r\\n    (range 1 10))" " (map\\r\\n       (fn[n] (list n (count (problem14/function n))))\\r\\n       (range 1 10))" ";; Loading file src\\\\problem14.clj" ";; Loading file src\\\\problem17.clj" "{ (list 1 2) }" "(+ 1 1)" ";; Loading file src\\\\problem17.clj" "{ (list 1 2) }" "{ 1 2 }" " { `(1 2) }" " { quote(1 2) }" "{ (quote 1 2) }" "(def *hundreds* { ;hundred (7)\\r\\n                 100 (+ (get *unities* 1) 7)\\r\\n                 200 (+ (get *unities* 2) 7)\\r\\n                 300 (+ (get *unities* 3) 7)\\r\\n                 400 (+ (get *unities* 4) 7)\\r\\n                 500 (+ (get *unities* 5) 7)\\r\\n                 600 (+ (get *unities* 6) 7)\\r\\n                 700 (+ (get *unities* 7) 7)\\r\\n                 800 (+ (get *unities* 8) 7)\\r\\n                 900 (+ (get *unities* 9) 7)\\r\\n                 })" "problem17/*hundreds*" "(merge {\:a \\"1\\"} {\:a \\"2\\"})" "(merge {\:a \\"1\\"} (list \:a \\"2\\"))" "(merge {\:a \\"1\\"} (hash-map (list \:a \\"2\\")))" "(merge {\:a \\"1\\"} (hash-map (list \:a \\"2\\",)))" "(merge {\:a \\"1\\"} \:a \\"2\\")" "(merge {\:a \\"1\\"} (hash-map \:a \\"2\\"))" "(conj {\:a \\"1\\"} (list \:a \\"2\\"))" "(conj {\:a \\"1\\"} [\:a \\"2\\"])" "(conj {\:a \\"1\\"} (seq \:a \\"2\\"))" "(conj {\:a \\"1\\"} (vec \:a \\"2\\"))" "(conj {\:a \\"1\\"} (vector \:a \\"2\\"))" "(conj {\:a \\"1\\"} (vector (list \:a \\"2\\")))" ";; Loading file src\\\\problem13.clj" "problem13/*big*" ";; Loading file src\\\\problem13.clj" "(map (fn[x]x) problem13/*big*)" "(map (fn[x] (if (\= x \\\\newline) \\\\0 x)) problem13/*big*)" "(int \\\\3)" "(int \\\\0)" "(- (int \\\\0) 48)" ";; Loading file src\\\\problem13.clj" "(str \\\\48 \\\\49)" "(str \\\\0 \\\\1)" "(split-at \#(\= % \\\\newline) problem13/*big*)" "(split-with \#(\= % \\\\newline) problem13/*big*)" "(count (split-with \#(\= % \\\\newline) problem13/*big*))" "(split-lines problem13/*big*)" "(clojure.string.split-lines problem13/*big*)" "(.split-lines clojure.string problem13/*big*)" ";; Loading file src\\\\problem13.clj" "(.split-lines string \\"asd\\\\nasd\\")" "(split-lines \\"asd\\\\nasd\\")" ";; Loading file src\\\\problem13.clj" "(split-lines \\"asdasd\\\\nqsdklasd\\")" ";; Loading file src\\\\problem13.clj" "(as-str 123)" "\\n(defn split-lines\\n  \\"Splits s on \\\\\\\\n or \\\\\\\\r\\\\\\\\n.\\"\\n  [\#^String s]\\n  (seq (.split \#\\"\\\\r?\\\\n\\" s)))" ";; Loading file src\\\\problem13.clj" "(int \\"123\\")" "(bigint 123)" "(Integer/parseInt \\"123123123\\")" "(Long/parseLong \\"123123123\\")" "(Long/parseLong \\"72107838435069186155435662884062257473692284509516\\")" "(BigInt/parseBigInt \\"72107838435069186155435662884062257473692284509516\\")" "(bigint 72107838435069186155435662884062257473692284509516)" "(BigInteger/parseBigInteger \\"72107838435069186155435662884062257473692284509516\\")" "(num \\"123\\")" ";; Loading file src\\\\problem13.clj" "(str 12312312313123312)" "(doc str)" "(.substring \\"asdasd\\" 1 1)" "(.subString \\"asdasd\\" 1 1)" "(.substring \\"asdasd\\" 1 2)" "(.substring \\"asdasd\\" 0 2)" ";; Loading file src\\\\problem13.clj" "(- \\\\0 48)" "(- (int \\\\0) 48)" "(partition 3 '(1 2 3 4 5 6 7 8 9))" "(* '(1 2 3))" "(reduce * '(1 2 3))" ";; Loading file src\\\\problem08.clj" "(.replace \\" \\\\n asd\\" '(\\\\n \\\\space \\\\t) \\"\\")" ";; Loading file src\\\\problem08.clj" "(map \\r\\n\\t\\t  (fn[x] (- (int x) 48))\\r\\n\\t\\t  *big*)" "(map \\r\\n   \\t\\t  (fn[x] (- (int x) 48))\\r\\n   \\t\\t  problem08/*big*)" "(partition \\r\\n\\t\\t  5\\r\\n\\t\\t  (map \\r\\n\\t\\t  (fn[x] (- (int x) 48))\\r\\n\\t\\t  problem08/*big*)" "(partition \\r\\n   \\t\\t  5\\r\\n   \\t\\t  (map \\r\\n   \\t\\t  (fn[x] (- (int x) 48))\\r\\n   \\t\\t  problem08/*big*))" "(map\\r\\n\\t  (fn[x] (reduce * x))\\r\\n\\t\\t(partition \\r\\n\\t\\t  5\\r\\n\\t\\t  (map \\r\\n\\t\\t  (fn[x] (- (int x) 48))\\r\\n\\t\\t  problem08/*big*)))" ";; Loading file src\\\\problem08.clj" ";; Loading file src\\\\problem48.clj" ";; Loading file src\\\\problem16.clj" ";; Loading file src\\\\problem48.clj" "(.subStr \\"asdqwe\\" 3 2)" "(.substr \\"asdqwe\\" 3 2)" "(.size \\"asdqwe\\")" "(.length \\"asdqwe\\")" "(doc let)" "(doc let*)" ";; Loading file src\\\\problem48.clj" ";; Loading file src\\\\problem12.clj" "(triang 1)" "(problem12/triang 12)" "(first problem12/triang)" "(first (problem12/triang))" ";; Loading file src\\\\problem12.clj" "(first (problem12/triang))" "(problem12/triang)" "(first (problem12/triang))" "(second (problem12/triang))" ";; Loading file src\\\\problem12.clj" ";; Loading file src\\\\problem03.clj" ";; Loading file src\\\\problem12.clj" "(divisors 6)" "(problem03/divisors 6)" ";; Loading file src\\\\problem12.clj" "(range 1 (inc 5))" ";; Loading file src\\\\problem12.clj" "(first (triang))" "(first (problem12/triang))" ";; Loading file src\\\\problem12.clj" "(first (problem12/triang))" ";; Loading file src\\\\problem12.clj" "(first (problem12/triang))" " (nth (problem12/triang) 2)" "(nth (problem12/triang) 1)" "(nth (problem12/triang) 0)" "(first (problem12/triang))" "(first (triang 1))" "(first (problem12/triang 1))" "(first (problem12/triang 2))" "(nth (problem12/triang 1) 1)" "(take 10 (nth (problem12/triang 1)))" "(take 10 (problem12/triang))" "(first (triang))" "(first (problem12/triang))" " (second (problem12/triang))" " (first (rest (problem12/triang)))" "(nth (problem12/triang) 0)" "(nth (problem12/triang) 1)" "(nth (problem12/triang) 2)" ";; Loading file src\\\\problem12.clj" "(nth (triang) 0)" "(nth (problem/triang) 0)" " (nth (problem12/triang) 0)" ";; Loading file src\\\\problem12.clj" "(nth (problem12/triang) 0)" "(nth (problem12/triang) 1)" "(nth (problem12/triang) 2)" " (nth (problem12/triang 1) 0)" ";; Loading file src\\\\problem12.clj" "(nth (problem12/triang 1) 0)" "(nth (problem12/triang 2) 0)" "(nth (problem12/triang 3) 0)" "(nth (problem12/triang 7) 0)" ";; Loading file src\\\\problem12.clj" "(nth (problem12/triang) 5000)" "(nth (problem12/triang) 5000000)" " (nth (problem12/triang 5000000) 0)" "(nth (problem12/triang 5000000) 1)" "(count (problem03/divisors 12500007500001))" "(problem03/divisors 12500007500001)" ";; Loading file src\\\\problem03.clj" ";; Loading file src\\\\problem12.clj" "(def *big* \\r\\n\\"7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450\\")\\r\\n" "(partition \\r\\n\\t\\t  5\\r\\n\\t\\t  (map \\r\\n\\t\\t  (fn[x] (- (int x) 48))\\r\\n\\t\\t  problem08/*big*))" "(partition \\r\\n\\t\\t  5\\n    4\\r\\n\\t\\t  (map \\r\\n\\t\\t  (fn[x] (- (int x) 48))\\r\\n\\t\\t  *big*))" "(partition \\r\\n   \\t\\t  5\\r\\n       1\\r\\n   \\t\\t  (map \\r\\n   \\t\\t  (fn[x] (- (int x) 48))\\r\\n   \\t\\t  *big*))" ";; Loading file src\\\\problem08.clj" ";; Loading file src\\\\problem12.clj" ";; Loading file src\\\\problem03.clj" ";; Loading file src\\\\problem12.clj" "(first (triang 100000))" "(first (problem12/triang 100000))" ";; Loading file src\\\\problem12.clj" "(first (problem12/triang 100000))" "(first (problem12/triang 500000000))" "(divisors (first (problem12/triang 500000000)))" "(problem03/divisors (first (problem12/triang 500000000)))" ";; Loading file src\\\\problem03.clj" ";; Loading file src\\\\problem05.clj" ";; Loading file src\\\\problem16.clj" ";; Loading file src\\\\problem05.clj" ";; Loading file src\\\\problem12.clj" ";; Loading file src\\\\problem03.clj" ";; Loading file src\\\\problem12.clj" "(get-factors 500)" "(reduce * '(2 2 5 5 5))" "(get-factors 500000)" ";; Loading file src\\\\problem12.clj" "(vals (decompose-list (get-factors 5000000)))" ";; Loading file src\\\\problem12.clj" "(problem12/count-divisors 15000000)" "(problem12/count-divisors 95000000)" "(problem12/count-divisors 95000000000)" " (problem12/count-divisors 9500000000000000)" ";; Loading file src\\\\problem12.clj" ";; Loading file src\\\\problem03.clj" ";; Loading file src\\\\problem05.clj" ";; Loading file src\\\\problem16.clj" ";; Loading file src\\\\problem05.clj" ";; Loading file src\\\\problem12.clj" "(first (triang 100000000000))" "(count-divisors (count-divisors head))" "(problem12/count-divisors 5000000000150000000000)" "(filter \#(mod % 2) '(1 2 3 4 5 6 7))" "(filter \#(\= (mod % 2) 0) '(1 2 3 4 5 6 7))" ";; Loading file src\\\\problem10.clj" "(defn sieve-eristh [under]\\r\\n  (let [my-primes (range 2 under)]\\r\\n    (loop [left-to-parse my-primes parsed-list '()]\\r\\n      (let [car (first left-to-parse)]\\r\\n        (if (nil? car)\\r\\n          parsed-list\\r\\n          (let [filtered (filter \#(not\= (mod \# head) 0) left-to-parse)] \\r\\n            (recur filtered (concat (list car) parsed-list))))))))" ";; Loading file src\\\\problem10.clj" "(defn sieve-eristh [under]\\r\\n  (let [my-primes (range 2 under)]\\r\\n    (loop [left-to-parse my-primes parsed-list '()]\\r\\n      (let [car (first left-to-parse)]\\r\\n        (if (nil? car)\\r\\n          parsed-list\\r\\n          (let [filtered (filter \#(not\= (mod \# car) 0) left-to-parse)] \\r\\n            (recur filtered (concat (list car) parsed-list))))))))\\r\\n\\r\\n" ";; Loading file src\\\\problem10.clj" "(problem10/sieve-eristh 100)" ";; Loading file src\\\\problem10.clj" "(problem10/sieve-eristh 100)" "(problem10/sieve-eristh 1000)" "(problem10/sieve-eristh 1000000)" "(filter \#(not\= (mod % 2) 0) (range 2 2000000))" ";; Loading file src\\\\problem10.clj" ";; Loading file src\\\\problem03.clj" "(+ 1 1)" ";; Loading file src\\\\problem03.clj" ";; Loading file src\\\\problem10.clj" "(problem10/sieve-eristh 2000000)" "(problem10/sieve-eristh 1000000)" "(problem10/sieve-eristh 10000)" "(problem10/sieve-eristh 100000)" "(get {\:a \\"teste\\"} \:b \\"doh\!\\") " "(get {\:a \\"teste\\"} \:a \\"doh\!\\")" "(vector 1 2 3 4 5)" "(vector (range 1 2000000))" "(apply vector (range 1 100))" " (apply vector (range 1 2000000))" "(nth (apply vector (range 1 2000000)) 1500)" "(nth (apply vector (range 1 2000000)) 0)" "(fn[x] (cons x (lazy-seq (recur (+ 4 x)))))" "(fn[x] (loop [t x] (cons t (lazy-seq (recur (+ 4 t))))))" "(defn x[y] (cons y (lazy-seq (recur (+ 4 y)))))" ";; Loading file src\\\\problem10.clj" "(fn\\n  ([] (recur 4))\\n  ([n] n))" "(fn this [x] (lazy-seq (cons x (this (+ x 4)))))" "(apply (fn this [x] (lazy-seq (cons x (this (+ x 4))))) 4)" "(apply (fn this [x] (lazy-seq (cons x (this (+ x 4))))) '(4))" "(first (apply (fn this [x] (lazy-seq (cons x (this (+ x 4))))) '(4)))" "(second (apply (fn this [x] (lazy-seq (cons x (this (+ x 4))))) '(4)))" "(nth (apply (fn this [x] (lazy-seq (cons x (this (+ x 4))))) '(4)) 0)" "(nth (apply (fn this [x] (lazy-seq (cons x (this (+ x 4))))) '(4)) 1)" "(nth (apply (fn this [x] (lazy-seq (cons x (this (+ x 4))))) '(4)) 2)" "(apply (fn this [x] (lazy-seq (cons x (this (+ x 4))))) '(4))" "(first (apply (fn this [x] (lazy-seq (cons x (this (+ x 4))))) '(4)))" "(second (apply (fn this [x] (lazy-seq (cons x (this (+ x 4))))) '(4)))" "(take-while \#(< % 2000000) (apply (fn this[x] (lazy-seq (cons x (this (+ x 5))))) 5))" "(take-while \#(< % 2000000) (apply (fn this[x] (lazy-seq (cons x (this (+ x 5))))) (list 5)))" "(take-while \#(< % 20) (apply (fn this[x] (lazy-seq (cons x (this (+ x 5))))) (list 5)))" "(take-while \#(< % 21) (apply (fn this[x] (lazy-seq (cons x (this (+ x 5))))) (list 5)))" "(doc take-while)" ";; Loading file src\\\\problem10.clj" "(assoc {} \:a \\"teste\\")" "(reduce\\n  (fn[acc v] (assoc acc v (\= (mod % 2) 0)))\\n  {}\\n  (range 1 2000000)\\n  )" "(reduce\\r\\n     (fn[acc v] (assoc acc v (\= (mod v 2) 0)))\\r\\n     {}\\r\\n     (range 1 2000000)\\r\\n     )" "(reduce\\r\\n        (fn[acc v] (assoc acc v (\= (mod v 2) 0)))\\r\\n        {}\\r\\n        (range 1 10)\\r\\n        )" "(defn y-combinator [le]\\r\\n\\t((fn[f] (f f))\\r\\n\\t(fn[f]\\r\\n\\t(le (fn[x] ((f f) x))))))" "((y-combinator (fn[x] (fn[y] (if (empty? y) 0 (inc (x (rest y)))))) '(1 2 3))" "((y-combinator (fn[x] (fn[y] (if (empty? y) 0 (inc (x (rest y))))))) '(1 2 3))" "((y-combinator (fn[x] (fn[y] (if (empty? y) 0 (inc (x (rest y))))))) '(1 2 3 4 5 6))"]
eclipse.preferences.version=1
